// DAZ Studio version 4.12.0.86 filetype DAZ Script

// Global Variables
var g_sBridge = "Maya"
var g_sDazBridgeName = String( "Daz To %1" ).arg( g_sBridge )
var g_oFileInfo = new DzFileInfo( getScriptFileName() );
var g_sScriptPath = g_oFileInfo.path();
if( g_sScriptPath === "" ){
	// To be able to use the IDE Input your absolute Path.
	g_sScriptPath = "D:/GitRepos/DazToMaya/Daz Studio/appdir_common/scripts/support/DAZ"
}	
g_oFileInfo.deleteLater();

// Global Includes
var g_sBridgeHelpers = String( "%2/dzBridgeUtils/Dz%1Helpers.dsa" ).arg( g_sBridge ).arg( g_sScriptPath );
var g_sBridgeMorphs = String( "%2/dzBridgeUtils/Dz%1Morphs.dsa" ).arg( g_sBridge ).arg( g_sScriptPath );
var g_sBridgeAutoWeight = String( "%2/dzBridgeUtils/Dz%1AutoWeight.dsa" ).arg( g_sBridge ).arg( g_sScriptPath );
var g_sBridgeExporter = String( "%2/dzBridgeUtils/Dz%1BridgeExporter.dsa" ).arg( g_sBridge ).arg( g_sScriptPath );

include( g_sBridgeHelpers ); // Dependencies : ...
include( g_sBridgeMorphs ); // Dependencies : DzBridgeHelper
include( g_sBridgeAutoWeight ); // Dependencies : DzBridgeHelper
include( g_sBridgeExporter ); // Dependencies : DzBridgeHelper, DzBridgeMorphs


(function( aArgs ){
	var s_oBridgeExporter;
	var s_oBridgeAutoWeights;

	var s_sToolName = g_sDazBridgeName;
	var s_sMorphDialog = String( "/dzBridgeUtils/Dz%1MorphSelectionDialog" ).arg( g_sBridge )
	var s_sSubdivDialog = String( "/dzBridgeUtils/Dz%1SubdivisionDialog" ).arg( g_sBridge )
	
	var s_aFigures = [];
	var s_aEnvProp = [];
	
	var s_sFig = "FIG";
	var s_sEnv = "ENV";

	var s_aToReparent = [];
	
	var s_oMeshTypes = {
		"Figure" :3,
		"Mesh" : 1,
		"Other" : 0,
		"Bone" : -1,
		"NoFacets" : -2,
		"Empty" : -3
	};
	
	var s_oExportTypes = {
		"Both" : 2,
		"Figure" : 1,
		"EnvProp" : 0,
		"None" : -1
	};
	var s_nExportType = s_oExportTypes.None;
	var s_aExportableProperties = [];


	var s_sRootPath = "";
	var s_sCustomPath = "";
	var s_sPresetPath = "";
	var s_sConfigPath = "";
	var s_sMorphPath = "";
	var s_sFbxPath = "";
	
	var s_aSubdivisionCombos = [];
	var s_oSkeletonData = {};
	var s_oLimitsData = {};
	var s_oHeadTailData = {};
	var s_oJointOrientation = {};
	var s_oPoseData = {};
	
	var s_vecDef = new DzVec3( 0, 0, 0 );
	var s_quatDef = new DzQuat( 0, 0, 0, 1, true );
	var s_mtxDef = new DzMatrix3( s_quatDef );
	
	var s_aPoseData = [];
	var s_oOrgName = {};

	// Setting variables
	var s_bSilent;
	var s_bIncludeSubdiv;
	var s_nSubDivLevel;
	var s_bIncludeAnim;
	var s_bRemoveIncompatible;
	var s_bIncludeMorphs;
	var s_bCollectTextures;
	var s_bAutoWeights;
	var s_bNewSubdiv;
	
	// Static Widgets
	var s_wAdvWgt;
	var wSettingsDialog;


	/*********************************************************************/
	/** 
	* Void: initalizes any arguments passed to the silent exporter
	*/
    function initilizeArgs()
    {
        for( var i = 0, nArgs = aArgs.length; i < nArgs; i += 1 ){
            vArg = aArgs[i];
            if( i == 0 ){
				s_bSilent = vArg;
			}
			else if( i == 1 ){
				s_nSubDivLevel = vArg;
			}
			else if( i == 2 ){
				s_bIncludeAnim = vArg;
			}
			else if( i == 3 ){
				s_bRemoveIncompatible = vArg;
			}
			else if( i == 4 ){
				s_bIncludeMorphs = vArg;
			}
			else if( i == 5 ){
				s_bCollectTextures = vArg;
			}
			else if( i == 6 ){
				s_bAutoWeights = vArg;
			}
			else if( i == 7 ){
				s_sMorphPath = vArg;
			}
			else if( i == 8 ){
				s_bNewSubdiv = vArg;
			}
        }

    };

	/*********************************************************************/
	// Array<Number> : ...
	// TODO : refactor - efficiency
	function getBoneTransformValues( oNode )
	{
		var aPosRotScale = [ 0, 0, 0, 0, 0, 0, 0, 0, 0 ];
		
		var aAxis = [ "X", "Y", "Z" ];
		var regxWhitespace = /\s+/g;
		
		var oProperty;
		var oOwner;
		var aNames;
		var sAxis;
		var sLabel;
		var sName;
		
		var aProperties = s_oBridgeExporter.getElementProperties( oNode, true, true );
		for( var i = 0; i < aProperties.length; i += 1 ){
			oProperty = aProperties[i];
			oOwner = oProperty.getOwner();
			if( !oOwner.inherits( "DzBone" ) ){
				continue;
			}
			
			for( var j = 0; j < aAxis.length; j += 1 ){
				sAxis = aAxis[j];
				aNames = [ sAxis + "Translate", sAxis + "Rotate" ];//Skip sAxis + "Scale"
				for( var k = 0; k < aNames.length; k += 1 ){
					sName = aNames[k];
					if( oProperty.name == sName ){
						if( !oProperty.isHidden() ){
							sLabel = oProperty.getLabel().toLowerCase().replace( regxWhitespace, "" );
							sName = sName.toLowerCase().replace( regxWhitespace, "" );
							if( !sName.startsWith( sLabel ) ){
								aPosRotScale[k*3+j] = 1;
							}
						}
					}
				}
			}
		}
		
		return aPosRotScale;
	};
	
	/*********************************************************************/
	// void : ...
	function writeMemo( sFilename, sMemo )
	{
		writeDataFile( [ sMemo ], sFilename );
	};
	
	/*********************************************************************/
	// void : ...
	function applyDefaultTransforms( oBaseNode )
	{
		var oNode;
		var aChildren = oBaseNode.getNodeChildren( true );
		for( var i = 0; i < aChildren.length; i += 1 ){
			oNode = aChildren[i];
			if( getObjectType( oNode ) == "BONE" ){
				oNode.setLocalPos( s_vecDef );
				oNode.setLocalRot( s_quatDef );
				oNode.setLocalScale( s_mtxDef );
			}
		}
		
		oBaseNode.setLocalPos( s_vecDef );
		oBaseNode.setLocalRot( s_quatDef );
		oBaseNode.setLocalScale( s_mtxDef );
	};

	/*********************************************************************/
	// Destructive Changes the names of the Assets in Daz
	// void : ...
	function updateName( oBaseNode, bIsFigure )
	{
		s_aPoseData = [];
		
		var aTopNodes = oBaseNode.getNodeChildren( false );
		if( aTopNodes.length == 0 && !bIsFigure ){
			aTopNodes.push( oBaseNode );
		}
		
		var oTopNode;
		
		var aNodes = [];
		
		for( var i = 0; i < aTopNodes.length; i += 1 ){
			oTopNode = aTopNodes[i];
			if( bIsFigure && oTopNode.name != "hip" ){
				continue;
			}
			
			if( i == 0 ){
				aNodes = aNodes.concat( oBaseNode, oTopNode, oTopNode.getNodeChildren( true ) );
			} else {
				aNodes = aNodes.concat( oTopNode, oTopNode.getNodeChildren( true ) );
			}
		}
		
		var nNodes = aNodes.length;
		if( nNodes < 1 ){
			return;
		}
		
		for( var i = 0; i < nNodes; i += 1 ){
			oNode = aNodes[i];
			sLabel =oNode.getLabel();
			sName = oNode.name;
			if( sLabel in s_oOrgName ){
				oNode.setName(s_oOrgName[sLabel])
			}
			else{
				s_oOrgName[sLabel] = sName
				oNode.setName( sLabel )
			}
			
		};
	};

	/*********************************************************************/
	// void : ...
	function loadPoseData( oBaseNode, bIsFigure )
	{
		s_aPoseData = [];
		
		var aTopNodes = oBaseNode.getNodeChildren( false );
		if( aTopNodes.length == 0 && !bIsFigure ){
			aTopNodes.push( oBaseNode );
		}
		
		var oTopNode;
		
		var aNodes = [];
		
		for( var i = 0; i < aTopNodes.length; i += 1 ){
			oTopNode = aTopNodes[i];
			
			if( bIsFigure && !oTopNode.inherits( "DzBone" ) ){
				continue;
			}

			if( i == 0 ){
				aNodes = aNodes.concat( oBaseNode, oTopNode, oTopNode.getNodeChildren( true ) );
			} else {
				aNodes = aNodes.concat( oTopNode, oTopNode.getNodeChildren( true ) );
			}
		}
		
		var nNodes = aNodes.length;

		if( nNodes < 1 ){
			return;
		}
		
		var oNode;
		var sObjectType;
		var vecPos;
		var quatRot;
		var mtxScale;
		s_oPoseData = {};
		for( var i = 0; i < nNodes; i += 1 ){
			oNode = aNodes[i];
			sObjectType = getObjectType( oNode );
			vecPos = oNode.getLocalPos();
			quatRot = oNode.getLocalRot();
			mtxScale = oNode.getLocalScale();
			oParent = oNode.getNodeParent();
			s_aPoseData.push( [ oNode.name, sObjectType, vecPos, quatRot, mtxScale ] );
			sLabel = oNode.getLabel();	
			sName = oNode.name;		
			oName = s_oPoseData[sName] = {};
			oName["Name"] = sName;
			oName["Label"] = sLabel;
			oName["Object Type"] = sObjectType;
			if(sObjectType == "MESH"){
				oName["Object"] = oNode.getObject().name; 
			}
			else{
				oName["Object"] = "EMPTY"
			};
			oName["Position"] = [
				vecPos.x,
				vecPos.y,
				vecPos.z
			];
			oName["Rotation"] = [
				oNode.getXRotControl().getLocalValue(),
				oNode.getYRotControl().getLocalValue(),
				oNode.getZRotControl().getLocalValue(),
				];
			oName["Scale"] = [
				mtxScale.m11,
				mtxScale.m22,
				mtxScale.m33
			];	
		}
	
		
	};
	
	/*********************************************************************/
	// void : ...
	function restorePose( oBaseNode )
	{
		var oTopNode;
		var aNodes;
		var oNode;
		var aPose;
		
		var aTopNodes = oBaseNode.getNodeChildren( false );
		for( var i = 0; i < aTopNodes.length; i += 1 ){
			oTopNode = aTopNodes[i];
			if( oTopNode.name != "hip" ){
				continue;
			}
			
			aNodes = oTopNode.getNodeChildren( true );
			aNodes.push( oTopNode );
			aNodes.unshift( oBaseNode );
			for( var j = 0; j < aNodes.length; j += 1 ){
				oNode = aNodes[j];
				if( getMeshType( oNode ) != s_oMeshTypes.Bone && j > 0 ){
					continue;
				}
				
				for( var k = 0; k < s_aPoseData.length; k += 1 ){
					aPose = s_aPoseData[k];
					if( aPose[0] == oNode.name ){
						oNode.setLocalPos( aPose[2] );
						oNode.setLocalRot( aPose[3] );
						oNode.setLocalScale( aPose[4] );
						break;
					}
				}
			}
		}
	};

	/*********************************************************************/
	// void : ...
	function changeLock ( oProperty, bLock ) {
		if ( ! oProperty ) {
			return;
		}
		oProperty.lock( bLock );
	}

	/*********************************************************************/
	// void : ...
	function setLock( oBaseNode, bLock, bIsFigure )
	{
		var aNodes = oBaseNode.getNodeChildren( true );
		if( !bIsFigure ){
			aNodes.push( oBaseNode );
		}
				
		var oNode;
		var oTransform;

		for( var i = 0; i < aNodes.length; i += 1 ){
			oNode = aNodes[i];
			if( getObjectType( oNode ) == 'BONE' ){
				continue;
			}
			// Translations
			oTransform = oNode.getXPosControl();
			changeLock( oTransform, bLock );
			oTransform = oNode.getYPosControl();
			changeLock( oTransform, bLock );
			oTransform = oNode.getZPosControl();
			changeLock( oTransform, bLock );
			
			// Rotations
			oTransform = oNode.getXRotControl();
			changeLock( oTransform, bLock );
			oTransform = oNode.getYRotControl();
			changeLock( oTransform, bLock );
			oTransform = oNode.getZRotControl();
			changeLock( oTransform, bLock );
			
			// Scale
			oTransform = oNode.getScaleControl();
			changeLock( oTransform, bLock );
			oTransform = oNode.getXScaleControl();
			changeLock( oTransform, bLock );
			curTransform = oNode.getYScaleControl();
			changeLock( oTransform, bLock );
			curTransform = oNode.getZScaleControl();
			changeLock( oTransform, bLock );
		}
	};
	
	/*********************************************************************/
	// String : ...
	function getObjectType( oNode )
	{
		if( oNode.inherits( "DzBone" ) ){
			return "BONE";
		}
		
		if( oNode.inherits( "DzLight" ) ){
			return "LIGHT";
		}
		
		if( oNode.inherits( "DzCamera" ) ){
			return "CAMERA";
		}
		
		var oObject = oNode.getObject();
		if( !oObject ){
			return "EMPTY";
		}
		
		var oShape = oObject.getCurrentShape();
		if( !oShape ){
			return "EMPTY";
		}
		
		var oMesh = oShape.getGeometry();
		if( !oMesh ){
			return "EMPTY";
		}
		
		return "MESH";
	};
	
	/*********************************************************************/
	// void : ...
	// Delete previous export
	// ISSUE : Currently the Both Enum is handled incorrectly new logic is needed
	function prepareForExport( nType )
	{
		var oDir = new DzDir( "" );
		var sPath = oDir.homePath() + "/";
		
		s_sRootPath = sPath;
		
		var aFiles;
		var sDelPath;
		var oDelDir = new DzDir( "" );
		
		var aRoot = ["Documents","DAZ 3D", "Bridges", s_sToolName] 
		var aFolders = ["Exports", "Config", "Presets"];
		var aSubs = [s_sEnv, s_sFig]

		for( var i = 0; i < aRoot.length; i += 1 ){
			// Create Base Directory
			
			sPath = s_sRootPath + aRoot[i] + "/";
			s_sRootPath = sPath;

			// Create Directories
			oDir.setPath( sPath );
			if( !oDir.exists() ){
				oDir.mkdir( sPath );
			};
		};
		for( var i = 0; i < aFolders.length; i += 1 ){
			// Create Folders 
			var sTempPath = sPath + aFolders[i] + "/";
			if( i == 0 ){
				s_sRootPath = sTempPath;
			}
			if( i == 1 ){
				s_sConfigPath = sTempPath;
			}
			if( i == 2 ){
				s_sPresetPath = sTempPath;
				if( s_sMorphPath == "" ){
					s_sMorphPath = s_sPresetPath + "LastUsed.csv"
				}
			}
			// Create Directories
			oDir.setPath( sTempPath );
			if( !oDir.exists() ){
				
				if( i == 0 ){
					MessageBox.information( qsTr( "You can manually locate your export files here:\n%1" ).arg( sTempPath ), 
											qsTr( "Your Export Path" ), 
											qsTr( "&Continue" ) );
				}
				oDir.mkdir( sTempPath );
			}
		}

		// Create Type Directories
		if(nType == s_oExportTypes.EnvProp ){
			sPath = s_sRootPath + aSubs[0] + "/"
			sType = aSubs[0]	
			};
		if(nType == s_oExportTypes.Figure ){
			sPath = s_sRootPath + aSubs[1] + "/"
			sType = aSubs[1]	
			};	
		
		if( nType == s_oExportTypes.Both ){
			sPath = s_sRootPath 
			sType = aSubs[0]	
		}
		
		// Create Directories
		oDir.setPath( sPath );
		if( !oDir.exists() ){
			oDir.mkdir( sPath );
		};
		
		// Find Users Daz Content Paths
		var aContentDir = findUsersContent( s_sConfigPath );
		writeConfigPath( aContentDir );

		// Replace RootPath if Custom Path is Enabled
		if( useCustomPath() ){
			sPath = sPath.replace( s_sRootPath, s_sCustomPath );
			oDir.setPath( sPath );
			s_sRootPath = s_sCustomPath;
		};

		var aDirs = []
		// Delete Files
		aFiles = oDir.getFilesFromDir( [], true );
		for( var j = 0; j < aFiles.length; j += 1 ){
			var oFile = new DzFile( aFiles[j] );
			var sFileName = oFile.fileName()
			dir = oDir.relativeFilePath( aFiles[j] ).replace(  sFileName, "" )
			aDirs.pushIfNotExists( dir );
			oDir.remove( aFiles[j] );

		};
	
		// Delete Dirs
		for ( var j = 0; j < aDirs.length; j += 1 ){
			sDelPath = sPath + aDirs[j]
			oDelDir.setPath( sDelPath );
			if( oDelDir.exists() ){
				sDirName = oDelDir.dirName()
				oDelDir.rmdir( sDelPath );
				if( oDelDir.cdUp() && sDirName != sType ){
					oDelDir.rmdir()
				}
			}	
		};

		
	};
	/*********************************************************************/
	// Array : Find the Daz Paths where content is installed
	function findUsersContent()
	{
		var oContentMgr = App.getContentMgr();
		var nContentDirCount = oContentMgr.getNumContentDirectories();
		var aContentDir = [];
		for(var i=0; i < nContentDirCount; i++){
			var sContentDirPath = oContentMgr.getContentDirectoryPath( i );
			aContentDir.push( sContentDirPath )
		}
		return aContentDir
		
	}
	/*********************************************************************/
	// void : ...
	function writeConfigPath( aContentDir )
	{
		var sDazPath = s_sConfigPath + "daz_paths.json";
		var oCurFile = new DzFile( sDazPath );
		var oDazFile = new DzFile( sDazPath );
		var oDazJson = {};
		oCurFile.open( DzFile.ReadOnly );
		var sDazFile = oCurFile.read();
		if ( sDazFile != "" ){
			oDazJson = JSON.parse( sDazFile )
		}
		oCurFile.close()
		oDazFile.open( DzFile.WriteOnly );

		if( oDazJson["Custom Path"] ){
			s_sCustomPath = oDazJson["Custom Path"];
		}

		oDazJson["Content Directories"] = aContentDir;
		oDazJson["Default Path"] = s_sRootPath;
		oDazJson["Custom Path"] = s_sCustomPath;
		
		oDazFile.write( JSON.stringify( oDazJson, null, 4 ) );
		oDazFile.close();

	};

	/*********************************************************************/
	// Boolean : Check if Custompath Should be Used.
	function useCustomPath()
	{
		var sDazPath = s_sConfigPath + "daz_paths.json";
		var oDazFile = new DzFile( sDazPath );
		var oDazJson = {};
		oDazFile.open( DzFile.ReadOnly );
		var sDazFile = oDazFile.read()
		if ( sDazFile ){
			oDazJson = JSON.parse( sDazFile )
		}
		oDazFile.close();
		return oDazJson["Use Custom Path"]
	};

	/*********************************************************************/
	// void : ...
	// TODO : refactor - efficiency
	function makeEndDir( nIdx, sName )
	{
		var oDir = new DzDir( "" );
		
		var sPath = s_sRootPath;
		
		var aSubs = [ sName, sName + nIdx ];
		for( var i = 0; i < aSubs.length; i += 1 ){
			sPath += aSubs[i] + "/";
			oDir.setPath( sPath );
			if( !oDir.exists() ){
				oDir.mkdir( sPath );
			}
		}
	};
	
	/*********************************************************************/
	// Bool : ...
	// Export Settings Dialog
	function promptSettings( oNode )
	{
		// Get the current style
        var oStyle = App.getStyle();
        // Get the general margin
        var nMargin = oStyle.pixelMetric( "DZ_GeneralMargin" );

		wSettingsDialog = new DzBasicDialog();
		wSettingsDialog.caption = s_sToolName + ": Settings";
		if( oNode ){
			wSettingsDialog.caption += " - " + oNode.getLabel();
		}
		
		var sKey = wSettingsDialog.caption.replace( / /g, "" ) + "Dlg";
		wSettingsDialog.getWidget().objectName = sKey;
		
		var wMainWgt = new DzWidget( wSettingsDialog );
		
		// Create Layouts
		var lytSettings = new DzVBoxLayout( wMainWgt );
        lytSettings.margin = nMargin;
        lytSettings.spacing = nMargin;
		var lytMorphs = new DzHBoxLayout( lytSettings );
        lytMorphs.margin = nMargin;
        lytMorphs.spacing = nMargin;
		var lytSubdiv = new DzHBoxLayout( lytSettings );
        lytSubdiv.margin = nMargin;
        lytSubdiv.spacing = nMargin;
				
		// Checkbox to include morph data
		var wIncludeMorphsCbx = new DzCheckBox( wMainWgt );
		wIncludeMorphsCbx.text = "Enable Morphs";
		wIncludeMorphsCbx.checked = false;
		lytMorphs.addWidget( wIncludeMorphsCbx );

		// Button to choose morph data
		var wChooseMorphsBut = new DzPushButton( wMainWgt );
		wChooseMorphsBut.text = "Choose Morphs";
		wChooseMorphsBut.minWidth = 350;
		lytMorphs.addWidget( wChooseMorphsBut );
		
		// Checkbox to export subdivisions
		var wEnableSubdivCbx = new DzCheckBox( wMainWgt );
		wEnableSubdivCbx.text = "Enable Subdivisions";
		wEnableSubdivCbx.checked = false;
		lytSubdiv.addWidget( wEnableSubdivCbx );

		// Button to choose subdivisions
		var wChooseSubdivBut = new DzPushButton( wMainWgt );
		wChooseSubdivBut.text = "Choose Subdivisions";
		wChooseSubdivBut.minWidth =  350;
		lytSubdiv.addWidget( wChooseSubdivBut );

		// Checkbox to include animation data
		var wIncludeAnimationsCbx = new DzCheckBox( wMainWgt );
		wIncludeAnimationsCbx.text = "Include animation data";
		wIncludeAnimationsCbx.checked = false;
		lytSettings.addWidget( wIncludeAnimationsCbx );

		// Advanced Settings
		var wAdvanceSettings = new DzGroupBox( wMainWgt );	
		wAdvanceSettings.title = "Advanced Settings";
		wAdvanceSettings.checkable = true;
		wAdvanceSettings.checked = false;
		wAdvanceSettings.setFixedWidth( 490 );
		lytSettings.addWidget( wAdvanceSettings )

		// Create Advance Settings Layout
		s_wAdvWgt = new DzWidget( wAdvanceSettings );
		var lytAdvance = new DzVBoxLayout( s_wAdvWgt );
		lytAdvance.margin = nMargin;
        lytAdvance.spacing = nMargin;
		s_wAdvWgt.hide();

		// Checkbox to collect textures at export
		var wCollectTexturesCbx = new DzCheckBox( s_wAdvWgt );
		wCollectTexturesCbx.text = "Collect Textures";
		wCollectTexturesCbx.checked = false;
		lytAdvance.addWidget( wCollectTexturesCbx );

		// Checkbox to Remove incompatible nodes
		var wRemoveIncompatible = new DzCheckBox( s_wAdvWgt );
		wRemoveIncompatible.text = "Remove any incompatible nodes";
		wRemoveIncompatible.checked = false;
		lytAdvance.addWidget( wRemoveIncompatible )

		// Checkbox to Use New Subdiv Export
		var wNewSubdiv = new DzCheckBox( s_wAdvWgt );
		wNewSubdiv.text = "Better Subdivision Export";
		wNewSubdiv.checked = false;
		lytAdvance.addWidget( wNewSubdiv )

		// Checkbox to use Transfer Utility
		var wTransferUtil = new DzCheckBox( s_wAdvWgt );
		wTransferUtil.text = "Auto-Weight";
		wTransferUtil.checked = false;
		lytAdvance.addWidget( wTransferUtil )

		// Create Connections
		wChooseMorphsBut.released.connect( oNode, executeMorphDialog );
		wChooseSubdivBut.released.connect( oNode, executeSubdivDialog );
		wAdvanceSettings.toggled.connect( wAdvanceSettings.checked, handleShowAdvancedSetting)

		//Help 
		wTransferUtil.whatsThis = "When a mesh like a button is not weighted it will not keep its location. \
When leaving daz to deal with it we will be automatically transfer the weights from the parents."

		wSettingsDialog.addWidget( wMainWgt );
		wSettingsDialog.setFixedSize( 500, 150 )
		wSettingsDialog.addStretch();
		// When user Cancels the dialog
		if( !wSettingsDialog.exec() ){
			return false;
		}
		
		// Set settings variables from the Dialog
		s_bIncludeSubdiv = wEnableSubdivCbx.checked
		s_bIncludeAnim = wIncludeAnimationsCbx.checked;
		s_bIncludeMorphs = wIncludeMorphsCbx.checked;
		s_bCollectTextures = wCollectTexturesCbx.checked;
		s_bRemoveIncompatible = wRemoveIncompatible.checked;
		s_bAutoWeights = wTransferUtil.checked;
		s_bNewSubdiv = wNewSubdiv.checked;

		// When user Accepts the dialog
		return true;
	};
	/*********************************************************************/
	// Void : Display the advanced widget.
	function handleShowAdvancedSetting( bChecked )
	{	
		if( bChecked ){
			s_wAdvWgt.show()
			// if( wSettingsDialog.height + s_wAdvWgt.height )
			wSettingsDialog.setFixedSize(wSettingsDialog.width,  wSettingsDialog.height + 75 )
		}
		else{
			wSettingsDialog.setFixedSize(wSettingsDialog.width, wSettingsDialog.height - s_wAdvWgt.height)
			s_wAdvWgt.hide()
			
		}
		
	};

	/*********************************************************************/
	function executeMorphDialog()
	{
		s_aExportableProperties = s_oBridgeExporter.executeSubScript(
			s_sMorphDialog, 
			[this, s_sPresetPath, s_sToolName] 
		);
	};

	/*********************************************************************/
	function executeSubdivDialog()
	{
		s_aSubdivisionCombos = s_oBridgeExporter.executeSubScript(
			s_sSubdivDialog, 
			[this] 
		)
	};

	/*********************************************************************/
	// void : ...
	// No eyelashes on .OBJ
	function setEyelashVisibility( oBaseNode, bOnOff )
	{
		var oNode;
		
		var aHide = [ "Eyelashes", "Eye_1", "Eye_2", "_Shell" ];
		var aChildren = oBaseNode.getNodeChildren( true );
		for( var i = 0; i < aChildren.length; i += 1 ){
			oNode = aChildren[i];
			if( oNode.getNodeParent() == oBaseNode ){
				for( var j = 0; j < aHide.length; j += 1 ){ 
					if( oNode.name.indexOf( aHide[j] ) > 0 ){
						oNode.setVisible( bOnOff );
					}
				}
			}
		}
	};

	/*********************************************************************/
	// string : ...
	function checkChildType( oChildNode )
	{
		var oAssetMgr = App.getAssetMgr();
		var sContentType = oAssetMgr.getTypeForNode( oChildNode );
		return sContentType
	};

	/*********************************************************************/
	// TODO: Add a UI to allow the user to choose how they wish to export every asset
	// void : Check the node and what type of export it is. 
	function findRootNodes( oNode )
	{
		var oParent;
		var oOrgParent;
		var aChildFigures = [];
		var sClassName = oNode.className();
		var oAssetMgr = App.getAssetMgr();
		var sContentType = oAssetMgr.getTypeForNode( oNode );
		if( sClassName == "DzFigure" 
		   || sClassName == "DzLegacyFigure" ){
			if( sContentType == "Actor/Character" 
				|| sContentType == "Actor" ){
				s_aFigures.push( oNode );
				return
			}
			else{
				s_aEnvProp.push( oNode );
				return
			}
		}
		if( sClassName == "DzGroupNode" ){
			aChildren = oNode.getNodeChildren( true );
			for( var j = 0; j < aChildren.length; j += 1 ){
				oChildNode = aChildren[j]
				sContentType = checkChildType( oChildNode );
				if( sContentType == "Actor/Character"
					|| sContentType == "Actor"){
					aChildFigures.push( oChildNode )
				}
			}
			if( aChildFigures.length > 0 ){
				for( var i = 0; i < aChildFigures.length; i++ ){
					var oChild = aChildFigures[i]
					s_aFigures.push( oChild )
					oParent = oChild.getNodeParent();
					if( oParent == oNode ){
						oNode.removeNodeChild( oChild, inPlace = true );
					}
					else{
						oOrgParent = oParent
						while( oParent != null ){
							oParent.removeNodeChild( oChild, inPlace = true );
							oParent = oChild.getNodeParent();
						}
						oParent = oOrgParent;
					}
					var aParentChain = new Array ( oParent, oChild );
					s_aToReparent.push( aParentChain );
				}
				return
			}
			else{
				s_aEnvProp.push( oNode );
				return
			}

		}
		else{
			s_aEnvProp.push( oNode );
			return
		} 
	};
	
	/*********************************************************************/
	// void : ...
	// TODO : refactor - use oNode.assetUri instead of oNode.name
	function buildRootLists()
	{
		var oNode;
		var aChildren;
		
		var aNodes = Scene.getNodeList();
		for( var i = 0; i < aNodes.length; i += 1 ){
			oNode = aNodes[i];
			if( !oNode.isVisible() ){
				if( oNode.isRootNode() ){ 
					oNode.setVisible( true );
					aChildren = oNode.getNodeChildren( true );
					for( var j = 0; j < aChildren.length; j += 1 ){
						aChildren[j].setVisible( true );
					}
				}
				continue;
			}
	
			if( oNode.isRootNode() && oNode.isVisible() ){
				findRootNodes( oNode )
			}
		}
	};

	/*********************************************************************/
	// void : ...
	function reparentFigure( oFigure )
	{
		var aPair
		for( var i = 0; i < s_aToReparent.length; i++ ){
			aPair = s_aToReparent[i]
			if( aPair[1] == oFigure ){
				aPair[0].addNodeChild( oFigure, inPlace = true)
				return
			}
		}
	}
	
	/*********************************************************************/
	// Number : ...
	function promptExportType()
	{
		var wDlg = new DzBasicDialog();
		wDlg.caption = "Select Export Type";
		
		var wLyt = new DzVBoxLayout( wDlg );
		wLyt.autoAdd = true;
		
		var wOptBG = new DzVButtonGroup( wDlg );
		wOptBG.columns = 1;
		
		var wRadioBtn;
		var aOptions = [ "Environment/Props", "Genesis8/3", "Both" ];
		for( var i = 0; i < aOptions.length; i += 1 ){
			wRadioBtn = new DzRadioButton( wOptBG );
			wRadioBtn.text = aOptions[i];
		}
		wOptBG.selected = s_oExportTypes.Figure;
		
		wDlg.addWidget( wOptBG );
		
		var oWidget = wDlg.getWidget();
		var sizeHint = oWidget.minimumSizeHint;
		var nHeight = sizeHint.height;
		var nWidth = sizeHint.width < 200 ? 200 : sizeHint.width;
		wDlg.setFixedSize( nWidth, nHeight );
		
		if( !wDlg.exec() ){
			return s_oExportTypes.None;
		}
		
		return wOptBG.selected;
	};
	
	/*********************************************************************/
	// Boolean : ...
	function isGenital( oNode )
	{
		var aKeys = [ "genital", "malegen_" ];
		if( getMeshType( oNode ) <= s_oMeshTypes.Other ){
			return false;
		}
		
		var sName = oNode.name.toLowerCase();
		for( var i = 0; i < aKeys.length; i += 1 ){
			if( sName.length == 2 && sName == aKeys[i]
			|| sName.length > 2 && sName.indexOf( aKeys[i] ) >= 0 ){
				if( oNode.findNodeChild( "hip", false ) ){
					return true;
				}
			}
		}
		
		return false;
	};
	
	/*********************************************************************/
	// void : ...
	// Mesh consisting of only edges and points cannot be FBX transferred.
	// Even if it is invisible, it will be transferred, so there is no choice but to delete it.
	// Note: destructive - modifies the scene contents
	function removeIncompatibleNodes( oBaseNode )
	{
		var oNode;
		
		var aNodes = oBaseNode.getNodeChildren( true );
		var aDelNodes = new Array( aNodes.length );
		
		for( var i = 0; i < aNodes.length; i += 1 ){
			oNode = aNodes[i];
			if( oNode.isRootNode() ){
				continue;
			}
			
			if( getMeshType( oNode ) == s_oMeshTypes.NoFacets ){
				aDelNodes[i] = oNode;
			}
		}
		
		aDelNodes = aDelNodes.filter( Boolean );
		
		for( var i = 0; i < aDelNodes.length; i += 1 ){
			oNode = aDelNodes[i];
			oBaseNode.removeNodeChild( oNode, true );
			oNode.setVisible( false );
			if( oNode.getLabel().endsWith( "dForce" ) ){
				Scene.removeNode( oNode );
			}
		}
	};
	
	/*********************************************************************/
	// Number : ...
	function getMeshType( oNode )
	{
		if( !oNode ){
			return s_oMeshTypes.Other; //0
		}
		
		if( oNode.inherits( "DzBone" ) ){
			return s_oMeshTypes.Bone; //-1
		}
		
		var oObject = oNode.getObject();
		if( !oObject ){
			return s_oMeshTypes.Empty; //-3
		}
		
		var oShape = oObject.getCurrentShape();
		if( !oShape ){
			return s_oMeshTypes.Other; //0
		}
		
		var oMesh = oShape.getGeometry();
		if( !oMesh ){
			return s_oMeshTypes.Other; //0
		}
		
		var nFacets = oMesh.getNumFacets();
		if( nFacets < 1 && oMesh.name.toLowerCase().indexOf( "eyebrow" ) < 0 ){
			return s_oMeshTypes.NoFacets; //-2
		}
		
		if( nFacets > 14000 ){
			return s_oMeshTypes.Figure; //3
		}
		
		if( oNode.isRootNode() ){
			return s_oMeshTypes.Other; //0
		}
		
		return s_oMeshTypes.Mesh; //1
	};
	
	/*********************************************************************/
	// void : ...
	// TODO : return success, error code, and/or message
	function writeDataFile( aData, sFilename )
	{
		var oFile = new DzFile( sFilename );
		if( !oFile.open( DzFile.WriteOnly ) ){
			print( String( "Unable to open \"%1\" for writing." ).arg( sFilename ) );
			
			return;
		}
		if (aData.constructor === Array){
			for( var i = 0; i < aData.length; i += 1 ){
				oFile.writeLine( aData[i] );
			}
		}	
		else{
			oFile.write( aData )
		}
			

		oFile.close();
	};
	
	/*********************************************************************/
	// void : ...
	// The mesh attached to the bone moves directly under the figure
	// Note: destructive - modifies the scene contents
	function flattenObjectHierarchy( oBaseNode )
	{
		var oChildLvl1;
		var vecChildLvl1Pos;
		var quatChildLvl1Rot;
		
		var aChildrenLvl2;
		var oChildLvl2;
		var vecChildLvl2Pos;
		var quatChildLvl2Rot;
		
		var aChildrenLvl1 = oBaseNode.getNodeChildren( true );
		for( var i = 0; i < aChildrenLvl1.length; i += 1 ){
			oChildLvl1 = aChildrenLvl1[i];
			if( getMeshType( oChildLvl1 ) != s_oMeshTypes.Empty ){
				continue;
			}
			
			vecChildLvl1Pos = oChildLvl1.getLocalPos();
			quatChildLvl1Rot = oChildLvl1.getLocalRot();
			
			aChildrenLvl2 = oChildLvl1.getNodeChildren( true );
			for( var j = 0; j < aChildrenLvl2.length; j += 1 ){
				oChildLvl2 = aChildrenLvl2[j];
				
				vecChildLvl2Pos = oChildLvl2.getLocalPos();
				quatChildLvl2Rot = oChildLvl2.getLocalRot();
				
				vecChildLvl2Pos.x += vecChildLvl1Pos.x;
				vecChildLvl2Pos.y += vecChildLvl1Pos.y;
				vecChildLvl2Pos.z += vecChildLvl1Pos.z;
				
				quatChildLvl2Rot.x += quatChildLvl1Rot.x;
				quatChildLvl2Rot.y += quatChildLvl1Rot.y;
				quatChildLvl2Rot.z += quatChildLvl1Rot.z;
				
				oChildLvl2.setLocalPos( vecChildLvl2Pos );
				oChildLvl2.setLocalRot( quatChildLvl2Rot );
				
				oBaseNode.addNodeChild( oChildLvl2 );
			}
		}
	};
	
	/*********************************************************************/
	// Array<String> : ...
	function getParentingData( oParentNode, oBaseNode )
	{
		var aData = [];
		
		var oNode;
		var sName;
		
		var aNodes = oBaseNode.getNodeChildren( true );
		aNodes.push( oBaseNode );
		for( var i = 0; i < aNodes.length; i += 1 ){
			oNode = aNodes[i];
			if( getMeshType( oNode ) <= s_oMeshTypes.Other ){
				continue;
			}
			
			sName = oNode.name;
			for( var j = 1; j <= 10; j += 1 ){
				if( !oNode.getLabel().endsWith( " (" + j + ")" ) ){
					continue;
				}
				
				sName += "_dup_" + j;
			}
			
			aData.push( oParentNode.name + "," + sName );
		}
		
		return aData;
	};
	
	/*********************************************************************/
	// void : ...
	function writeParentingData( oBaseNode, sFilename )
	{
		var aData = [];
		
		var oChildLvl1;
		
		var aChildrenLvl2;
		var oChildLvl2;
		
		var aChildrenLvl3;
		var oChildLvl3;
		
		var nMeshType;
		
		var aChildrenLvl1 = oBaseNode.getNodeChildren( true );
		for( var i = 0; i < aChildrenLvl1.length; i += 1 ){
			oChildLvl1 = aChildrenLvl1[i];
			
			aChildrenLvl2 = oChildLvl1.getNodeChildren( false );
			for( var j = 0; j < aChildrenLvl2.length; j += 1 ){
				oChildLvl2 = aChildrenLvl2[j];
				
				nMeshType = getMeshType( oChildLvl2 );
				//It's mesh(child)
				if( nMeshType > s_oMeshTypes.Other ){
					//Parent is bone
					if( getMeshType( oChildLvl1 ) == s_oMeshTypes.Bone ){
						aData = aData.concat( getParentingData( oChildLvl1, oChildLvl2 ) );
					}
				//It's Empty(Child)
				} else if( nMeshType == s_oMeshTypes.Empty ){
					aChildrenLvl3 = oChildLvl2.getNodeChildren( false );
					for( var k = 0; k < aChildrenLvl3.length; k += 1 ){
						oChildLvl3 = aChildrenLvl3[k];
						//Grandchild is mesh.
						//child's parent, parent child (sibling?) is bone
						if( getMeshType( oChildLvl3 ) > s_oMeshTypes.Other ){
							if( getMeshType( oChildLvl1.getNodeParent() ) == s_oMeshTypes.Bone ){
								aData = aData.concat( getParentingData( oChildLvl1, oChildLvl3 ) );
							}
						}
					}
				}
			}
		}
		
		if( aData.length > 0 ){
			writeDataFile( aData, sFilename );
		}
	};
	
	/*********************************************************************/
	// void : ...
	// Apply subdivision levels to figures and genitals.
	function setSubDivLevelAll( oBaseNode )
	{
		var bIsBody;
		var bIsGen;
		var nLev;
		var oNode;
		
		var aNodes = Scene.getNodeList();
		for( var i = 0; i < aNodes.length; i += 1 ){
			oNode = aNodes[i];
			bIsBody = oNode == oBaseNode;
			bIsGen = !bIsBody && oNode.getNodeParent() == oBaseNode && isGenital( oNode );
			nLev = 0;
			if( bIsBody || bIsGen ){
				nLev = s_nSubDivLevel;
			}
			
			setSubDivLevel( oNode, nLev );
		}
	};
	
	/*********************************************************************/
	// void : ...
	function setSubDivLevel( oNode, nLevel )
	{
		var aProps = [ "lodlevel", "SubDIALevel" ];
		var oObject = oNode.getObject();
		if( !oObject ){
			return;
		}
		
		var oShape = oObject.getCurrentShape();
		if( !oShape ){
			return;
		}
		
		var oProp;
		for( var i = 0; i < aProps.length; i += 1 ){
			oProp = oShape.findProperty( aProps[i] );
			if( oProp ){
				if( oProp.isLocked() ){
					oProp.lock( false );
				}
				
				if( i == 0 && nLevel == 0 ){
					oProp.setValue( "Basic" );
				} else {
					oProp.setValue( nLevel );
				}
				
				if( nLevel > 0 ){
					oProp.lock( true );
				}
			}
		}
	};
	
	/*********************************************************************/
	// void : ...
	function setHideRoot( bIsFigure, bYesNo )
	{
		if( bIsFigure ){
			for( var i = 0; i < s_aFigures.length; i += 1 ){
				setVisible( s_aFigures[i], bYesNo );
			}
		} else {
			for( var i = 0; i < s_aEnvProp.length; i += 1 ){
				setVisible( s_aEnvProp[i], bYesNo );
			}
		}
	};
	
	/*********************************************************************/
	// void : ...
	function setVisible( oBaseNode, bYesNo )
	{
		var aChildren = oBaseNode.getNodeChildren( true );
		for( var i = 0; i < aChildren.length; i += 1 ){
			aChildren[i].setVisible( bYesNo );
		}
		
		oBaseNode.setVisible( bYesNo );
	};

	/*********************************************************************/
	// Number : Get the sign of the input number
	function getSign( nInput )
	{
		if( nInput >= 0 ){
			return 1;
		} else{
			return -1;
		}
	};

	/*********************************************************************/
	// Number : Get the direction of the bone's look at axis. 1 or -1
	function getLookAtDirection( oNode )
	{
		var vecLookAtAxis = oNode.getEndPoint().subtract( oNode.getOrigin() );
		
		var nSign = 1;
		if( oNode.getRotationOrder().firstAxis == 0 ){
			nSign = getSign( vecLookAtAxis.x );
		} else if( oNode.getRotationOrder().firstAxis == 1 ){
			nSign = getSign( vecLookAtAxis.y );
		} else if( oNode.getRotationOrder().firstAxis == 2 ){
			nSign = getSign( vecLookAtAxis.z );
		}
		
		return nSign;
	};

	/*********************************************************************/
	// DzVec3 : Get the second axis of the node
	function getNodeSecondAxis( oNode )
	{
		var vecSecondAxis = new DzVec3( 0, 0, 0 );
		var nSign = getLookAtDirection( oNode );
		
		if( oNode.getRotationOrder().secondAxis == 0 ){
			vecSecondAxis.x = nSign;
		} else if( oNode.getRotationOrder().secondAxis == 1 ){
			vecSecondAxis.y = nSign;
		} else if( oNode.getRotationOrder().secondAxis == 2 ){
			vecSecondAxis.z = nSign;
		}
		
		var quatOrientation = oNode.getOrientation();
		vecSecondAxis = quatOrientation.multVec( vecSecondAxis );
		
		return vecSecondAxis;
	};

	/*********************************************************************/
	// DzVec3 : Get the primary axis of the node
	function getNodePrimaryAxis( oNode, nBoneLength )
	{
		var vecFirstAxis = new DzVec3( 0, 0, 0 );
		var nSign = getLookAtDirection( oNode );
		var nNodeScale = oNode.getScaleControl().getValue();
		
		if( oNode.getRotationOrder().firstAxis == 0 ){
			nXScale = oNode.getXScaleControl().getValue();
			vecFirstAxis.x = nBoneLength * nSign * nXScale * nNodeScale;
		} else if( oNode.getRotationOrder().firstAxis == 1 ){
			nYScale = oNode.getYScaleControl().getValue();
			vecFirstAxis.y = nBoneLength * nSign * nYScale * nNodeScale;
		} else if( oNode.getRotationOrder().firstAxis == 2 ){
			nZScale = oNode.getZScaleControl().getValue();
			vecFirstAxis.z = nBoneLength * nSign * nZScale * nNodeScale;
		}
		
		var quatOrientation = oNode.getOrientation();
		vecFirstAxis = quatOrientation.multVec( vecFirstAxis );
		
		return vecFirstAxis;
	};
	/*********************************************************************/
	// DzVec3 : Checks if there is an offset for Parent bone
	// TODO: Check if any other bones are changed with FBMs
	function getBoneOffset( oNode )
	{
		var vecOffset = new DzVec3( 0, 0, 0)
		for( var i = 0; i < oNode.getNumProperties(); i++ ){
			var oProperty = oNode.getProperty( i );
			var sPropName = oProperty.getName();
			// Currently only checking YTranslate
			if( sPropName == "YTranslate" ){
				var nControllerCount = oProperty.getNumControllers();
				for( var j = 0; j < nControllerCount; j += 1 ){
					var oErcLink = new DzERCLink();
					oErcLink = oProperty.getController( j );
					var oControllerProp = oErcLink.getProperty();
					sControllerName = s_oBridgeExporter.getPropertyName(oControllerProp);
					if( oControllerProp.getDoubleValue() != 0 ){
						vecOffset.y += oErcLink.scalar * oControllerProp.getDoubleValue();
					};
					
				};
			};
		};
		return vecOffset
	};
	
	/*********************************************************************/
	// Float : Get length of the bone
	function getBoneNodeLength( oNode )
	{
		var vecAlongBone = oNode.getEndPoint().subtract( oNode.getOrigin() );
		return vecAlongBone.length();
	};

	/*********************************************************************/
	// Void : load bone's limits along with rotation orders
	function loadFigureBoneData( oBaseNode )
	{

		if( !oBaseNode.inherits( "DzFigure" ) ){
			if( !oBaseNode.inherits( "DzLegacyFigure" ) ){
				return;
			}
		}
		var oSkeleton = oBaseNode.getSkeleton();
		var aNodes = oSkeleton.getAllBones();
		var numFollowers = oSkeleton.getNumFollowSkeletons();
		var oFollowSkeleton;
		var aFollowNodes;
		var oFollowNode;
		var bIsNewNode;
		
		// Collect followers' bones that does not exist in the main skeleton
		for( var i = 0; i < numFollowers; i += 1 ){
			oFollowSkeleton = oSkeleton.getFollowSkeleton( i );
			aFollowNodes = oFollowSkeleton.getAllBones();
			for( var j = 0; j < aFollowNodes.length; j += 1 ){
				oFollowNode = aFollowNodes[j];
				bIsNewNode = false;
				for( var k = 0; k < aNodes.length; k += 1 ){
					if( oFollowNode.name == aNodes[k].name ){
						bIsNewNode = true;
						break;
					}
				}

				if( bIsNewNode == false ){
					aNodes = aNodes.concat( aFollowNodes[j] );
				}
			}
		}
		
		var nNodes = aNodes.length;
		if( nNodes == 0 ){
			return;
		}
		
		var oNode;
		var sRotOrder;
		var nXRotMin;
		var nXRotMax;
		var nYRotMin;
		var nYRotMax;
		var nZRotMin;
		var nZRotMax;
		var nXOrientation;
		var nYOrientation;
		var nZOrientation;
		var vecOffset;
		
		// To account for the scale on the skeleton due to morphs
		var nSkeletonScale = oBaseNode.getScaleControl().getValue();
		s_oSkeletonData["skeletonScale"] = ["skeletonScale", nSkeletonScale];
		// To account for offset on the hip bone.
		vecOffset = getBoneOffset(aNodes[0])
		s_oSkeletonData["offset"] = ["offset", vecOffset.y];

		oBaseNode.update();
		oBaseNode.finalize();
		var oFigure = new DzFigure();
		
		var oFigure = oBaseNode.getSkeleton();
		if ( oBaseNode.className() != "DzLegacyFigure" ){
			var oSkinBinding = oFigure.getSkinBinding();
		}
		
		for( var i = 0; i < nNodes; i += 1 ){
			oNode = aNodes[i];
			
			sRotOrder = oNode.getRotationOrder().toString();
			nXRotMin = oNode.getXRotControl().getMin();
			nXRotMax = oNode.getXRotControl().getMax();
			nYRotMin = oNode.getYRotControl().getMin();
			nYRotMax = oNode.getYRotControl().getMax();
			nZRotMin = oNode.getZRotControl().getMin();
			nZRotMax = oNode.getZRotControl().getMax();
			nXOrientation = oNode.getOrientXControl().getValue();
			nYOrientation = oNode.getOrientYControl().getValue();
			nZOrientation = oNode.getOrientZControl().getValue();
			quatOrientation = oNode.getOrientation();

			s_oLimitsData[oNode.getName()] = [
				oNode.getName(),
				sRotOrder,
				nXRotMin, nXRotMax,
				nYRotMin, nYRotMax,
				nZRotMin, nZRotMax
				];

			nBoneLength = getBoneNodeLength( oNode );
			vecPrimaryAxis = getNodePrimaryAxis( oNode, nBoneLength );

			vecHead = oNode.getOrigin( false );
			if ( oBaseNode.className() != "DzLegacyFigure" ){
				oBoneBinding = oSkinBinding.findBoneBinding( oNode );
				if( oBoneBinding ){
					vecHead = oBoneBinding.getScaledOrigin();
				}
			}
			
			vecTail = vecHead.add( vecPrimaryAxis );
			vecSecondAxis = getNodeSecondAxis( oNode );
			
			s_oHeadTailData[oNode.getName()] = [
				( vecHead.x + vecOffset.x ) * nSkeletonScale,
				( vecHead.y + vecOffset.y ) * nSkeletonScale,
				( vecHead.z + vecOffset.z ) * nSkeletonScale,
				( vecTail.x + vecOffset.x ) * nSkeletonScale,
				( vecTail.y + vecOffset.y ) * nSkeletonScale,
				( vecTail.z + vecOffset.z ) * nSkeletonScale,
				vecSecondAxis.x,
				vecSecondAxis.y,
				vecSecondAxis.z
				]
				.concat( getBoneTransformValues( oNode ) );

			s_oJointOrientation[oNode.getName()] = [
				sRotOrder,
				nXOrientation,
				nYOrientation,
				nZOrientation,
				quatOrientation.w,
				quatOrientation.x,
				quatOrientation.y,
				quatOrientation.z
			]
			
		}
	};
	
	/*********************************************************************/	
	// String : Configure DTU File
	function writeConfiguration( oNode, sFilename, sDir )
	{
		var sDtufilename = sFilename + ".dtu";
		var oDtufile = new DzFile( sDtufilename );
		var oDtuJson = {};
		var aChildren = oNode.getNodeChildren( true );
		var nChildren = aChildren.length;
		var oAssetMgr = App.getAssetMgr();
		var sContentType = oAssetMgr.getTypeForNode( oNode );
		
		oDtuJson["Asset Name"] = oNode.getLabel();
		oDtuJson["Import Name"] = oNode.getName();
		oDtuJson["Asset Type"] = sContentType;
		oDtuJson["FBX File"] = s_oBridgeExporter.sFbxPath;
		oDtuJson["Materials"] = [];
		oDtuJson["Subdivisions"] = []
		oDtuJson["MorphLinks"] = s_oBridgeExporter.oMorphLinks;
		oDtuJson["MorphNames"] = s_oBridgeExporter.aMorphNamesToExport;
		oDtuJson["SkeletonData"] = s_oSkeletonData;
		oDtuJson["HeadTailData"] = s_oHeadTailData;
		oDtuJson["JointOrientation"] = s_oJointOrientation;
		oDtuJson["LimitData"] = s_oLimitsData;
		oDtuJson["PoseData"] = s_oPoseData;
		
		aFigureMats = writeMaterials( oNode, sDir );
		oDtuJson["Materials"].push( aFigureMats );
		if (nChildren > 0){
			for ( var i = 0; i < nChildren; i++ ){
				var oChild = aChildren[ i ]; 
				aChildMats = writeMaterials( oChild, sDir );
				if ( aChildMats != false ){
					oDtuJson["Materials"].push( aChildMats );
				}		
			}
		};
		function combineMaterials( key, value ){
			var aNewMaterials = [];
			if( key == "Materials" ){
				for (var i=0; i < value.length; i++ ){
					var aNodeMats = value[i];
					for (var k=0; k < aNodeMats.length; k++ ){
						var aMat = aNodeMats[k];
						aNewMaterials.push( aMat );
					}
				}
				return aNewMaterials;
			}
			else{
				return value;
			}
		};
		
		oDtuJson["Subdivisions"] = writeSubdivisions()

		oDtufile.open( DzFile.WriteOnly );
		oDtufile.write( JSON.stringify( oDtuJson, combineMaterials, 4 ) );
		oDtufile.close();
		return sDtufilename
	};
	/*********************************************************************/
	// String : Writes Texture and returns new Path
	// TODO: Find a better method to get the paths
	function writeTexture( sDir, sOrigTexture, sAssetName )
	{
		var oOrigFile = new DzFile( sOrigTexture );
		var sOrgImageName = oOrigFile.fileName();
		var sAbsPath = oOrigFile.absolutePath();
		var aSplitPath = sAbsPath.split("Textures");
		var sPath = String( "%1/%2/%3" ).arg( sDir ).arg( "Textures" ).arg( sAssetName );
		
		var oDir = new DzDir( "" );
		oDir.setPath( sPath );
		if( !oDir.exists() ){
			oDir.mkpath( sPath );
		}
		oDir.setPath( s_sRootPath )

		var sNewTexture = String( "%1/%2" ).arg( sPath ).arg( sOrgImageName )
		var sRelTexture = oDir.relativeFilePath( sNewTexture )
		oOrigFile.copy( sNewTexture )
		return sRelTexture
		
	};

	/*********************************************************************/	
	// Array : ...
	// Note: Cycle through all the Materials on a Node and return an array
	function writeMaterials( oNode, sDir )
	{	
		var oObj = oNode.getObject();
		if( oObj != null ){
			var oShape = oObj.getCurrentShape();
			var aMaterials = [];
			if( oShape ){
				for( var k = 0; k < oShape.getNumMaterials(); k++ ){
					var oMaterialInfo = {};
					var aProperties = [];
					var oMat = oShape.getMaterial( k );
					if( oMat ){	
						oMaterialInfo["Asset Name"] = oNode.name;
						oMaterialInfo["Asset Label"] = oNode.getLabel();
						oMaterialInfo["Material Name"] = oMat.getName();
						oMaterialInfo["Material Type"] = oMat.getMaterialName();
						
						// Get presentation and set material info
						var oPresentation = oNode.getPresentation();
						if( oPresentation != undefined ){
							var sPresentationType = oPresentation.type
							oMaterialInfo["Value"]  = sPresentationType;
						}
						else{
							oMaterialInfo["Value"]  = "Unknown";
						}

						// Load all the porperties info
						for( var i = 0; i < oMat.getNumProperties(); i++ ){
							var oProperty = oMat.getProperty( i );
							var oPropertyInfo = {};
							
							oPropertyInfo["Name"] = oProperty.getName();
							oPropertyInfo["Label"] = oProperty.getLabel();
							
							var bImageProperty = oProperty.inherits( "DzImageProperty" );
							var bColorProperty = oProperty.inherits( "DzColorProperty" );
							var bNumericProperty = oProperty.inherits( "DzNumericProperty" );
							var sTextureName = "";

							if( bImageProperty ){
								if(oProperty.getValue()){
									sTextureName = oProperty.getValue().getFilename();	
								}
								oPropertyInfo["Value"] = oMat.getDiffuseColor().name;
								oPropertyInfo["Data Type"] = "Texture";
								oPropertyInfo["Texture"] = sTextureName;
							}
							else if( bColorProperty ){
								if ( oProperty.getMapValue() ){
									sTextureName = oProperty.getMapValue().getFilename();
								}
								oPropertyInfo["Value"] = oProperty.getColorValue().name;
								oPropertyInfo["Data Type"] = "Color";
								oPropertyInfo["Texture"] = sTextureName;
							}
							else if( bNumericProperty ){
								if ( oProperty.getMapValue() ){
									sTextureName = oProperty.getMapValue().getFilename();
								}
								oPropertyInfo["Value"] = oProperty.getValue();
								oPropertyInfo["Data Type"] = "Double";
								oPropertyInfo["Texture"] = sTextureName;
							}
							aProperties.push( oPropertyInfo );
							if ( sTextureName != "" ){
								if(s_bCollectTextures){
									sNewTexture = writeTexture( sDir, 
																sTextureName,
																oMaterialInfo["Asset Label"]);
									oPropertyInfo["Texture"] = sNewTexture;
								}
							}
						}
						oMaterialInfo["Properties"] = aProperties;
						
						aMaterials.push( oMaterialInfo );
					}
				}						
			}
			return aMaterials
		}
		else{
			return false
		}
	};

	/*********************************************************************/
	/** 
	* Void: Used to export out the subdivisions chosen by user. 
	* @param {Boolean} bSubdivEnabled - Based on user's input to export out Subdivisions.
	*/
    function lockSubdivisionProperties( bSubdivEnabled )
    {
        for( var i = 0; i < s_aSubdivisionCombos.length; i++ ){
            var oSubdivInfo = s_aSubdivisionCombos[i]
            oNode = oSubdivInfo.node;
            oObject = oNode.getObject();
            if( oObject ){
                oShape = oObject.getCurrentShape();
                oGeo = oShape.getGeometry();
                if( oGeo ){
                    nVertCount = oGeo.getNumVertices();
                    for( var i = 0; i < oShape.getNumProperties(); i++ ){
                        oProperty = oShape.getProperty( i );
                        oPropName = oProperty.getName();
						if( oPropName == "lodlevel" ){
                            if( bSubdivEnabled ){
                                oProperty.setValue( 1 )
                            }
                            else{
                                oProperty.setValue( 0 )
                            }
                        }
                        if( oPropName == "SubDIALevel" ){
                            oProperty.lock( false );
                            if( bSubdivEnabled ){
                                var nTargetValue = oSubdivInfo.currentItem;
                                oProperty.setDoubleValue( nTargetValue )
                            }
                            else{
                                oProperty.setDoubleValue( 0.0 )
                            }
                            oProperty.lock( true )
                        }
                    }
                }
            }
        }
    };

    /*********************************************************************/
	/** 
	* Void: Writes out the subdivision levels that were chosen by the user to the DTU
	* @return {Array} Contains the data that will be added to the DTU
	*/
    function writeSubdivisions()
    {
        aSubdivisions = []
        for( var i = 0; i < s_aSubdivisionCombos.length; i++ ){
            var oSubdivInfo = s_aSubdivisionCombos[i]
            var sNodeName = oSubdivInfo.name + ".Shape";
            var nTargetValue = oSubdivInfo.currentItem;
            oSubdivision = {
                "Version" : 1,
                "Asset Name" : sNodeName,
                "Value" : nTargetValue
                }
            aSubdivisions.push( oSubdivision )
        }
        return aSubdivisions
    };

	/*********************************************************************/
	/** 
	* Void: Used to run the DzFBXBridges and allow the skin weights to be transferred
	* @param {String} sDtufilename - Path for the DTU File
	*/ 
	function processFBX( sDtufilename )
	{
		oProcess = new DzProcess()
		oProcess.communication = DzProcess.Stdin | DzProcess.Stdout | DzProcess.Stderr;	
		oProcess.arguments = [String( '"%2/dzBridgeUtils/DzFBXBridges.exe" "%1"' ).arg( sDtufilename ).arg( g_sScriptPath ) ];
		print(String( '"%2/dzBridgeUtils/DzFBXBridges.exe" "%1"' ).arg( sDtufilename ).arg( g_sScriptPath ))
		connect( oProcess, "readyReadStdout()", this, "readStdout" );
		connect( oProcess, "readyReadStderr()", this, "readStderr" );
		oProcess.start()
	};
	
 
	/*********************************************************************/
	/** 
	* Void: Used to check if the fbx sdk 2020 exists in the path needed
	*/
	function isSubdivPrereq()
	{
		if( s_bNewSubdiv ){
			oFileInfo = new DzFileInfo( String( '%1/dzBridgeUtils/libfbxsdk.dll' ).arg( g_sScriptPath ) );
			if( !oFileInfo.exists() && MessageBox.warning(
				qsTr( "To use subdivision the FBX SDK 2020 is needed." ),
				s_sToolName, qsTr( "&OK" ), qsTr( "&Cancel" ) ) == 1 ){
				return;
			}
			else{
				return true
			}
		}
		else{
			return
		}
	}

	/*********************************************************************/
	// void : ...
	function main()
	{
		var bDebugFBX = false;
		initilizeArgs()
		buildRootLists();
		
		if( !s_bSilent ){
			if( s_aFigures.length > 2 ){
				if( MessageBox.warning(
					qsTr( "Transferring 3 or more figures with clothing or hair may freeze and stop." ),
					s_sToolName, qsTr( "&OK" ), qsTr( "&Cancel" ) ) == 1 ){
					return;
				}
			}
			
			if( s_aFigures.length == 0 && s_aEnvProp.length == 0 ){
				return;
			} else if( s_aFigures.length > 0 && s_aEnvProp.length > 0 ){
				s_nExportType = s_oExportTypes.Both;
			} else if( s_aEnvProp.length == 0 ){
				s_nExportType = s_oExportTypes.Figure;
			} else if( s_aFigures.length == 0 ){
				s_nExportType = s_oExportTypes.EnvProp;
			}
			
			if( s_nExportType == s_oExportTypes.Both ){
				s_nExportType = promptExportType();
			}
			
			if( s_nExportType == s_oExportTypes.None ){
				return;
			}
		}
		else{
			s_nExportType= s_oExportTypes.Both
		}
		prepareForExport( s_nExportType );
		
		var sFileBasename;
		var sBaseDirectory; 

		// Instantiate Classes and add dependencies
		s_oBridgeExporter = new DzBridgeExporter( s_sToolName, 
												  g_sScriptPath,
												  s_sRootPath,
												  s_sFbxPath );
		s_oBridgeAutoWeights = new DzBridgeAutoWeight( s_sRootPath );
		if( s_nExportType == s_oExportTypes.Both
		|| s_nExportType == s_oExportTypes.Figure ){
			setHideRoot( false, false );
			
			var oFigure;
			for( var i = 0; i < s_aFigures.length; i += 1 ){
				oFigure = s_aFigures[i];
				
				for( var j = 0; j < s_aFigures.length; j += 1 ){
					setVisible( s_aFigures[j], i == j );
				}
				if( !s_bSilent ){
					if( !promptSettings( oFigure ) ){
						continue;
					}
					s_oBridgeExporter.bIncludeAnim = s_bIncludeAnim;
				}
				if( s_bAutoWeights ){ 
					if( !s_bSilent ){
						if( MessageBox.warning(
							qsTr( "Transfering the Weights will destroy the current state of your scene save your scene before exporting." ),
							s_sToolName, qsTr( "&Continue" ), qsTr( "&Cancel" ) ) == 1 ){
							return;
						}
					};
					s_oBridgeAutoWeights.weightObjects( oFigure )
				}

				setLock( oFigure, true, true );
				makeEndDir( i, s_sFig );
				
				
				// Morph Export
				if( s_bIncludeMorphs ){
					s_oBridgeExporter.getMorphString( s_aExportableProperties );
					s_oBridgeExporter.loadMorphLinks( s_aExportableProperties, oFigure );
					s_oBridgeExporter.disconnectMorphs( s_aExportableProperties );
				};	
				// Export Figure
				loadFigureBoneData( oFigure );
				loadPoseData( oFigure, true );
				
				if( s_bRemoveIncompatible ){
					removeIncompatibleNodes( oFigure );
				}
				if( s_bIncludeSubdiv && isSubdivPrereq() ){
					lockSubdivisionProperties( true );
					setEyelashVisibility( oFigure, false );
					s_oBridgeExporter.exportOBJ( oFigure, s_sFig, i, false );
					setEyelashVisibility( oFigure, true );
					s_oBridgeExporter.exportFBX( oFigure, s_sFig, i , "_HD" , bDebugFBX );
					lockSubdivisionProperties( false );
					s_oBridgeExporter.exportFBX( oFigure, s_sFig, i , "_base" , bDebugFBX );
				}
				else if( s_bIncludeSubdiv ){
					lockSubdivisionProperties( true );
					setEyelashVisibility( oFigure, false );
					s_oBridgeExporter.exportOBJ( oFigure, s_sFig, i, false );
					setEyelashVisibility( oFigure, true );
					s_oBridgeExporter.exportFBX( oFigure, s_sFig, i , "" ,bDebugFBX );
				}
				else{
					lockSubdivisionProperties( false );
					setEyelashVisibility( oFigure, false );
					s_oBridgeExporter.exportOBJ( oFigure, s_sFig, i, false );
					setEyelashVisibility( oFigure, true );
					s_oBridgeExporter.exportFBX( oFigure, s_sFig, i , "" ,bDebugFBX );
				}
				setLock( oFigure, false, true );
				restorePose( oFigure );
				reparentFigure( oFigure );
				if ( s_bIncludeMorphs ){
					s_oBridgeExporter.reconnectMorphs( s_aExportableProperties );
					// reconnectSkeleton( oFigure );
				}

				// Write data
				sFileBasename = String( "%1%2/%2%3/%2" ).arg( s_sRootPath ).arg( s_sFig ).arg( i );
				sBaseDirectory = String( "%1%2/%2%3" ).arg( s_sRootPath ).arg( s_sFig ).arg( i );
				writeParentingData( oFigure, sFileBasename + ".dat" );
				sDtufilename = writeConfiguration( oFigure, sFileBasename, sBaseDirectory );
				if( s_bIncludeSubdiv && s_bNewSubdiv ){
					processFBX( sDtufilename )
				}
				

			}
		}
		
		if( s_nExportType != s_oExportTypes.Figure ){
			setHideRoot( true, false );
			
			var oNode;
			var bIsBone;
			var sEnvPath;
			var sPoseFilename;
			var sFileBasename;
			
			for( var i = 0; i < s_aEnvProp.length; i += 1 ){
				oNode = s_aEnvProp[i];

				for( var j = 0; j < s_aEnvProp.length; j += 1 ){
					setVisible( s_aEnvProp[j], i == j );
				}
				
				bIsBone = oNode.getSkeleton() != null;
				if( bIsBone ){
					flattenObjectHierarchy( oNode );
				}
				else{
					setLock( oNode, true, false );
				}
				
				
				setSubDivLevelAll( oNode, 0 );
				
				sEnvPath = String( "%1%2/%2%3/" ).arg( s_sRootPath ).arg( s_sEnv ).arg( i );
				makeEndDir( i, s_sEnv );
				
				if( oNode.name.startsWith( "Genesis" ) ){
					applyDefaultTransforms( oNode );
				}
				
				updateName( oNode );
				
				s_oBridgeExporter.exportFBX( oNode, s_sEnv, i, bDebugFBX );
				
				sFileBasename = sEnvPath + s_sEnv;
				sPoseFilename = sFileBasename + ".transforms";
				
				if( bIsBone ){
					loadFigureBoneData( oNode );
					loadPoseData( oNode, true );
				} else {
					loadPoseData( oNode, false );
					writeMemo( sEnvPath + "nobone.txt", "not skeleton" );
					setLock( oNode, false, false );
				}
				updateName( oNode );
				
				writeConfiguration( oNode, sFileBasename );

				
			}
		}
		
		setHideRoot( true, true );
		setHideRoot( false, true );
	};
	
	/*********************************************************************/
	main();

})( getArguments() );